<div class="t">流动的程序设计：流程</div>
<p class="tr">白晓阳 2011年3月</p>
<ul>
	<li class="b">面向对象的三板斧</li>
	<p>主管要求小程设计一个简单的仓库，他毫不犹豫地选择了面向对象。</p>
	<p>面向对象的程序设计该怎样进行呢？</p>
	<p>没错，正如教科书所讲：抽象、封装、继承……</p>
	<p>小程首先抽象出【货物】、【库房】与【保管员】三个对象，然后分别为它们封装属性和行为，结果大致如下：</p>
	<div>
		<div class="box w190 fl">
			<div class="t">货物</div>
			<p>属性：名称</p>
			<p>属性：位置</p>
			<p>属性：数量</p>
		</div>
		<div class="box w190 fl">
			<div class="t">库房</div>
			<p>属性：库存清单</p>
			<p>行为：入库</p>
			<p>行为：出库</p>
			<p>行为：查找货物</p>
			<p>行为：更新库存</p>
		</div>
		<div class="box w190 fl">
			<div class="t">保管员</div>
			<p>行为：记录流水账</p>
			<p>行为：汇报库存</p>
		</div>
	</div>
	<p>很简单嘛，已经可以开始使用了！</p>
	<p>然而没过几天，保管员就开始抱怨：【库房】总爱偷懒！每次入库或者出库之后，她都得提醒【库房】去更新库存。如果一时疏忽了，她就不得不花费大量的时间去重新清点库存。这本来不就应该是【库房】的分内之事吗？</p>
	<p>唔，这个简单，修改一下【库房】的入库与出库行为，让它们去执行更新库存就行了。</p>
	<p>没等小程松口气，主管又要求小程为每件货物增加一个条形码，以便扫描条形码来识别货物。</p>
	<p>这个就麻烦多了：需要给【货物】增加新的属性：条形码，同时给【库房】增加新的行为：贴条形码和识别货物，并修改所有既有的行为，以适用于条形码的方式，而且要把这些变化告知保管员。</p>
	<p>小程正忙于修改程序，保管员又提出一个新点子：【库房】应该更勤快点，自动记录流水账，这样她就不用担心会漏记流水账了。</p>
	<p>还有，主管要求货物分类放置，方便以后拆分仓库……</p>
	<p>需求总是在不断变化……</p>
	<p>小程很快发现，【库房】的行为增加到了十几个甚至更多，保管员对此晕头转向，威胁说如果小程不改善仓库，她就跳槽……</p>
	<p>正当小程一筹莫展时，一个叫【工场】的家伙跳了出来，声称能改变这一切……</p>
	<li class="b">使用工场</li>
	<p>先来看看工场的名片：</p>
	<div>
		<div class="box w190">
			<div class="t">工场</div>
			<p>行为：开工</p>
			<p>其他对外保密</p>
		</div>
	</div>
	<p>【工场】接着做自我介绍：</p>
	<ol>
		<li>工场只开放一个常规公开入口（如果必须开放其他入口，也应是静态入口）</li>
		<li>工场（理论上）只做一件事情或者一类事情</li>
		<li>工场（理论上）是独立的、封闭的</li>
		<li>工场相对固定，不随入口数据的变化而变化</li>
	</ol>
	<p>唔，貌似很单纯又很神秘的一个家伙！小程决定尝试从【工场】继承一个【库房工场】：</p>
	<div>
		<div class="box w300">
			<div class="t">库房工场</div>
			<p>行为：开工</p>
			<p>内部属性：库存清单</p>
			<p>内部行为：入库、出库、查找货物、更新库存、识别货物……</p>
		</div>
	</div>
	<p>这下保管员开心了，她只需要告诉【库房】：来货物了，开工啦，或者，嘿，出库单来了，快开工……库房就会把所有的任务依次完成。</p>
	<p>不过小程就比较郁闷了，他不得不对每一种情况进行判断，如果是货物，【库房】需要入库、贴条形码、更新库存、记录流水账，如果是出库单，【库房】需要出库、更新库存、记录流水账……</p>
	<p>而且，假如以后要添加一个行为，可能所有的流程都会受到影响……想一想小程就头大如斗……</p>
	<p>嘿！【工场】再次跳了出来，不要把流程放进【工场】里，那是另一个家伙【流程】的事情，【工场】只是用来“做”事情的！不过，一件事往往不是简简单单的一件事，所以，告诉你一个好消息</p>
	<ol>
		<li>工场具备动态执行自己的行为的能力</li>
		<li>工场能够按照预置流程（像一道流水线一样）智能运作</li>
	</ol>
	<li class="b">智能工场</li>
	<p>小程顿时来了兴致，怎么才能让工场智能运作？</p>
	<p>首先，需要设置预置流程，外部配置文件是个不错的选择：</p>
	<div>
		<div class="box w300">
			<div class="t">库房工场预置流程</div>
			<p>货物入库：入库、贴条形码、更新库存、记录流水账……</p>
			<p>清单出库：出库、更新库存、记录流水账……</p>
			<p>默认流程：……</p>
		</div>
	</div>
	<p>这下轻松多了，货物来的时候，只需要把预置流程同时交给【库房】，由于它的动态执行能力，它就会像流水线一样从头执行到尾：入库、贴条形码、更新库存、记录流水账；出库清单来的时候也一样。如果没有找到合适的预置流程，它就会去执行默认流程。而且，如果以后需要更改流程，甚至不用修改设计，只需要修改预置流程就行了。更妙的是，如果不小心发现了以前留下的问题，小程可以悄悄的修改好，而不必通知任何人去适应这个改变。</p>
	<p>不管小程增加、删除还是修改了【库房】的行为，在保管员看来，【库房】都没有发生变化，她再也不用为【库房】的频繁变更而上火了。</p>
	<p>对此小程提出了一个新的想法：【库房】应该更智能点，只需要告诉它货物要入库，它会自己找到预置流程并执行。</p>
	<p>没错，这是一个非常棒的想法。由于【工场】的封闭特性，我们有两个选择：</p>
	<ol>
		<li>把预置流程作为必须的构造参数</li>
		<li>使用一种类似的方式：预置工场。</li>
	</ol>
	<li class="b">预置工场</li>
	<p>单例模式我们都非常熟悉，无论我们怎么创建或者获取对象，它总是一个静态的唯一的实体。这非常适合于记录流水账一类的事情。</p>
	<p>注意下面这个单例，看看它有什么不同：</p>
	<pre class="box">
	class LogWork extends Work { ### by PHP
		private static $ACCESS = null; 
		public function __construct($preset = null){ 
			if (! self::$ACCESS) {
				# 初始化
			} 
			return self::$ACCESS;
		}
	}
	</pre>
	<p>似乎与把预置流程作为构造参数没什么不同。</p>
	<p>是的，除了单例，仅仅有一些使用上的不同：</p>
	<pre class="box">
	### 预置区域
	$log = new LogWork($preset);
	
	### 后续使用
	$log = new LogWork();
	</pre>
	<p>这样做有什么好处？通过在预置区域的预置构建，后续处理即可不必关注构建细节，而随意使用。而且，通过不同的预置构建，可以实现不同的处理细节，而不必去修改内部程序。</p>
	<p>甚至不会让人感觉到与普通的对象有什么区别。当然，除了应用的局限，不应把这种用法泛化，而仅应用于适用单例的对象。</p>
	<p>然而，随着货物的种类和数量越来越多，仓库不得不拆分成四个，小程发现了一个新的问题：对于拆分出来的新【库房】，显然也要使用条形码，由于【工场】的封闭性，难道每个库房都要准备一套条形码序列？显然它们应该使用同一套！</p>
	<p>是的，除了从基类继承封闭工场，还有一种特殊的工场：露天工场。</p>
	<li class="b">露天工场</li>
	<p>露天工场特殊在哪里呢？</p>
	<ol>
		<li>露天工场有任意多个入口（因为它是露天的嘛）</li>
		<li>露天工场的属性与行为全部是静态的、公开的</li>
		<li>露天工场不能被继承</li>
		<li>工场能也只能访问露天工场</li>
	</ol>
	<p>这样看起来，露天工场完全是一个公共属性与行为库，所有的【工场】都可以直接的不受约束的访问，而且也只能访问露天工场。可以简单的把它们理解成一个【工场】群，露天工场就是最核心的、可以供所有【工场】自由出入的那个。</p>
	<img alt="露天工场" src="<?php echo _ISSUE; ?>style/img/openwork.png"></img>
	<p>还记得【工场】的第一个特点吗？如果必须开放其他入口，也应是静态入口。一个封闭的【工场】如果必须送外卖，那么就要把外卖窗口做成露天工场。</p>
	<p>好容易弄明白了这一点，小程的新麻烦又来了：主管在四个仓库之外又设立了一个加工厂，根据原料的库存情况加工生肉片或者火腿。如果加工厂也做成一个【工场】，因为封闭的特性，天啊，谁去访问【库房】？保管员？她绝对跳槽！</p>
	<p>哈哈，你终于说到重点了，这个当然是【流程】的拿手好戏啦，它早就迫不及待要出来晒一晒了！</p>
	<li class="b">了解流程</li>
	<p>【流程】与【工场】有什么区别？</p>
	<p>【工场】，沉默而专注，他只做一件事，一件他最擅长的很少发生变化的事情。我们只需要给他一个消息，他就能一丝不苟地把整件事做完做好。</p>
	<p>【流程】，活泼而多变，她根据情况的变化与若干不同的【工场】打交道，使他们协作起来进而完成艰巨而又复杂多变的任务。进一步的，她可能还需要别的【流程】的协作。</p>
	<p>为什么要有流程？</p>
	<p>程序设计，总是希望把善变与不变分开，同时又要非常方便的做出改变。</p>
	<p>不管换上什么样的外衣，程序的基本功能往往很少改变，改变的是组织与访问他们的方式，改变的是程序的【流程】。</p>
	<p>好像是这样，小程点点头，不管【库房】怎么改变，他的基本行为其实并没有什么变化，只是小程的设计与使用的方式在不断变化。唔，为了更方便维护，更易于使用……</p>
	<p>来看看流程的名片（与工场如出一辙）：</p>
	<div>
		<div class="box w190">
			<div class="t">流程</div>
			<p>行为：开工</p>
			<p>其他对外保密</p>
		</div>
	</div>
	<p>流程的开场白：</p>
	<ol>
		<li>流程只开放一个常规公开入口</li>
		<li>流程具备动态获取与使用工场和其他流程的能力</li>
		<li>流程通过有序的组织工场以及与其他流程相复合，进而完成高级的复杂的任务</li>
		<li>流程相对易变，入口数据的不同可能导致流程的改变</li>
	</ol>
	<p>因为【流程】与【工场】的相似性，所以【工场】的智能也适用于【流程】。</p>
	<p>小程决定使用【流程】来进一步完善他的设计。</p>
	<li class="b">使用流程</li>
	<p>来看看新的设计图：</p>
	<img alt="设计图" src="<?php echo _ISSUE; ?>style/img/flowd.png"></img>
	<p>再来看看【加工流程】的流程：</p>
	<img alt="加工流程" src="<?php echo _ISSUE; ?>style/img/flow.png"></img>
	<p>可以开工了，看看【加工工场】的运转情况吧。</p>
	<p>好像一切正常。</p>
	<p>等等，库存的生肉和配料已经用完了，【加工工场】还在运转……</p>
	<p>小程悄悄地修改了【加工流程】的流程，在工人和保管员都不知道的情况下，工场正确的停止了下来。</p>
	<p>因为小程的这次优秀表现，他甚至获得了奖金。</p>
	<p>不过小程并没有止步于此，他决定给流程增加智能，就像智能工场所表现的一样。</p>
	<li class="b">智能流程</li>
	<p>需求总是在不断变化……</p>
	
</ul>
<p></p>